// 1. Loading
// Bootstrap ClassLoader грузит базовые модули JDK.
// Platform ClassLoader рузит платформенные модули
// Application ClassLoader прогружзает пользовательские классы (.class) JvmComprehension
// Байткод хранится в Metaspace (область памяти JVM для метаданных классов. Сюда попадают описание класса, поля, константы)
// Metaspace: JvmComprehension
// Object, Integer, System, String, System

// 2. Linking
// verify - проверка байткода метаданных. Гарантировать корректность формата.
// prepare - подготовка статическихз полей (память и значения по умолчанию), создание таблиц, методов/интерфейсов
//    для каждого static поля выделяется память и присваивается значение по умолчанию. Не устанавливаются значения из инициаторов
//    Формируются внутреннние таблицы методов
//    Создается java.lang.Class оъект (метаданные класса) в хип.Описание класса/поля/методы/constant pool
// resolve - размещение символических ссылок
//    В constant pool класса куча символических ссылок: на другие классы, поля и методы. Превращает их в "прямые" ссылки на реальные структуры JVM

// 3. Initialization
// Выполгняются static инициализоваторы и инициализоваторы static полей в порядке текста. предварительно инициализируется супер класс. Только после инициализации класс считается готовым к использованию.
// Запускается ровно один раз синхронизированно.
// Если класс имеетс суперкласс - сначала инициализируется суперкласс.
// Выполняется статический инициализатор static {} и инициализаторы статических полей в порядке появления в исходном коде

// Heap(хип) - хранит экземпляры объектов и java.lang.Class(объекты-представителя классов) и др.

// Stack (стек) - кадры(фреймы) активных методов

public class JvmComprehension {
// В стеке создается фрейм для метода main
    public static void main(String[] args) {
        int i = 1;                      // 1 Application ClassLoader находит и загружает JvmComprehension, создает метаданные в Metaspace. Не выделятеся память в хип. Хранится в стеке
        Object o = new Object();        // 2 Выполняется new Object(). В хип создается объект Object. В стеке main создается переменая о - ссылка на объект.
        Integer ii = 2;                 // 3 JVM кэширует Integer от -128 до 127 в хип. В стеке создается ссылка ii, указывающая на объект в хип
        printAll(o, i, ii);             // 4 Создается новый фрейм в стэк для метода printAll. В нем размещаются o - ссылка на объект в хип new Object(). i - копия значения 1 (примитивный тип данных, хранится в стеке). ii - ссылка на объект Integer в хип
        System.out.println("finished"); // 7 СОздается новый фрейм. "finished" хранится в хип в String Pool. Выводится на консоль
        // После завершения фрейм метода main уничтожается. Все локальные переменные исчезают. Объекты, на которые нет ссылок, становятся кандидатами на Garbage Collection
    }
C
    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5 Так как- число вне диапазона от -128 до 127, то создается новый объект в хип. В этом фреме хранится ссылка uselessVar
        System.out.println(o.toString() + i + ii);  // 6 Создается новый фрейм. В хип создается новая строка при сложении строк.
        // После возврата из printAll фрейм удаляется. Локальные переменные o, i, ii исчезают. Объект Integer uselessVar становится кондидатом на Garbage Collection, так как на него не осталось ссылок
    }
}
